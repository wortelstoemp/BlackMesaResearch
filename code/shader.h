#pragma once

// Author(s): Simon, Tom

// TODO(Tom): Usage

struct ShaderUniform
{
	const char* name;	
	GLint id;
};

struct ShaderProgram
{
	GLuint shaderProgram;

	//NOTE(Simon): According to the spec it's illegal to pass a shaderID that's not been generated by OpenGL
	//NOTE(cont.): to a shaderProgram. So we want to it here, instead of in CreateShader. in CreateShader we would
	//NOTE(cont.): have to check if the shader is actually filled *again*
	void CompileAndAttachShader(int programID, char** source, GLenum shaderType) const
	{
		if (*source == 0)
		{
			return;
		}
	
		int size = strlen(*source);
		int shaderID = glCreateShader(shaderType);
		glShaderSource(shaderID, 1, source, &size);
		glCompileShader(shaderID);

		int compiled;
		glGetShaderiv(shaderID, GL_COMPILE_STATUS, &compiled);
		if (compiled != GL_TRUE)
		{
			GLsizei log_length = 0;
			GLchar message[1024];
			glGetShaderInfoLog(shaderID, 1024, &log_length, message);
			printf("%s\n", message);
		}

		glAttachShader(programID, shaderID);
		glDeleteShader(shaderID);
	}

	void Create(
		char* vertexSource,
		char* tessControlSource,
		char* tessEvalSource,
		char* geometrySource,
		char* fragmentSource)
	{
		shaderProgram = glCreateProgram();
	
		CompileAndAttachShader(shaderProgram, &vertexSource, GL_VERTEX_SHADER);
		CompileAndAttachShader(shaderProgram, &tessControlSource, GL_TESS_CONTROL_SHADER);
		CompileAndAttachShader(shaderProgram, &tessEvalSource, GL_TESS_EVALUATION_SHADER);
		CompileAndAttachShader(shaderProgram, &geometrySource, GL_GEOMETRY_SHADER);
		CompileAndAttachShader(shaderProgram, &fragmentSource, GL_FRAGMENT_SHADER);

		glLinkProgram(shaderProgram);

		int linked;
		glGetProgramiv(shaderProgram, GL_LINK_STATUS, &linked);
		if (linked != GL_TRUE)
		{
			GLsizei log_length = 0;
			GLchar message[1024];
			glGetProgramInfoLog(shaderProgram, 1024, &log_length, message);
			printf("%s\n", message);
		}
	}

	inline void Delete()
	{
		glDeleteProgram(shaderProgram);
	}

	inline void Use()
	{
		glUseProgram(shaderProgram);
	}
	
	inline void Unuse()
	{
		glUseProgram(0);		
	}
	
	inline bool AddUniform(ShaderUniform* uniform)
	{
		uniform->id = glGetUniformLocation(shaderProgram, (const GLchar*)uniform->name);
		return (uniform->id != -1);
	}
	
	inline void SetUniform(const ShaderUniform& uniform, const bool value)
	{
		glUniform1i(uniform.id, (GLint)(value ? 1 : 0));
	}
	
	inline void SetUniform(const ShaderUniform& uniform, const int value)
	{
		glUniform1i(uniform.id, (GLint)value);
	}
	
	inline void SetUniform(const ShaderUniform& uniform, const unsigned int value)
	{
		glUniform1ui(uniform.id, (GLuint)value);
	}
	
	inline void SetUniform(const ShaderUniform& uniform, const float value)
	{
		glUniform1f(uniform.id, (GLfloat)value);
	}
	
	inline void SetUniform(const ShaderUniform& uniform, const Vec2& value)
	{
		glUniform2f(uniform.id, (GLfloat)value.X, (GLfloat)value.Y);
	}
	
	inline void SetUniform(const ShaderUniform& uniform, const Vec3& value)
	{
		glUniform3f(uniform.id, (GLfloat)value.X, (GLfloat)value.Y, (GLfloat)value.Z);
	}
	
	inline void SetUniform(const ShaderUniform& uniform, const Vec4& value)
	{
		glUniform4f(uniform.id, (GLfloat)value.X, (GLfloat)value.Y, (GLfloat)value.Z, (GLfloat)value.W);
	}
	
	inline void SetUniform(const ShaderUniform& uniform, const Matrix4x4& value)
	{
		glUniformMatrix4fv(uniform.id, 1, GL_TRUE, (GLfloat*)value.values);
	}
};


// Basic way to create new shaders.
// This is the default shader.
struct DefaultShader
{
	ShaderProgram program;
	
	void Init()
	{
		
	}
	
	void Use()
	{
		program.Use();
	}
	
	void Unuse()
	{
		program.Unuse();
	}
};